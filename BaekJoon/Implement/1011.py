"""
* 이전 이동 거리 = prev_move
1. 이동 시 무조건 (prev_move-1), (prev_move), (prev_move+1)
2. 거리 = 도착 지점 - 출발지점
3. 처음 이동 & 마지막 도착 지점의 이동은 무조건 1

# 규칙 찾기
1. 이동 횟수: 1, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, .... 으로 늘어나고 있다.
    * 반복한 횟수가 같은 숫자끼리 묶을 경우: (1, 2), (3, 3, 4, 4), (5, 5, 5, 6, 6, 6), ...
                                -> ( 1, 1 ),    (2, 2)  ,       (3, 3), ....
    y-x 반복 횟수 규칙: (1), (1+1), (1+1+2), (1+1+2+2), (1+1+2+2+3), (1+1+2+2+3+3), ....

## 규칙을 통해 유추한 point
1. 빨간색 경계선
: n과의 관계 = n*(n+1)
2. 초록색 경계선
: y-x (총 이동 거리)가 n의 제곱보다 작거나 같을 때 -> 공간 이동 작동 횟수 = (n*2)-1
                    n의 제곱보다 클 때 -> 공간 이동 작동 횟수 = n*2
"""

test_count = int(input())

for _ in range(test_count):
    x, y = map(int, input().split())

    distance = y - x

    n = 0

    while True:
        if distance <= n * (n+1):
            break
        n += 1

    # 총 이동 거리가 n의 제곱보다 작거나 같을 때
    if distance <= n**2:
        print((n*2)-1)

    # 총 이동 거리가 n의 제곱보다 클 경우
    else:
        print(n*2)